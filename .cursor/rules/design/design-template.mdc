---
description: 
globs: 
alwaysApply: true
---
---
description:详细设计模板
globs:["'*.md"]
alwaysApply:true
---
# 详细设计模板
> 详设术语定义

|术语|含义|示例|工程对标|数字编码
|----|----|----|----|----|
|业务流程|按照业务发生的顺序和规则表达企业实现目标的各项业务活动|商品发布流程、交易下单流程|工作流程|三位数字编码a.b.c，第一位a代表业务流程
|业务活动|企业实现目标的业务活动，指业务角色办理的业务事项，例如用户发起的一个操作|发布商品、下单|API能力（接口、MQ、Job）|三位数字编码a.b.c，第二位b代表业务活动
|业务任务|完成业务活动的工作程序，是流程的基本组成单元|查询商品详情、创建订单|领域能力|三位数字编码a.b.c，第三位c代表业务任务
|业务步骤|完成任务的具体步骤，是流程的最原子操作|校验商品状态、订单计价|领域服务处理步骤
|业务规则|定义或约束业务步骤的细节规则，控制或影响业务行为|商品可用才允许下单|详细的业务判断条件

## 一、业务分析

### 1. 名词定义
> 定义名词，介绍名词含义和案例

|名词|含义|举例|
|-----|-----|------|
| 名词1 | 名词含义 | 名词案例 |

### 2. 业务流程
> 表达业务流程流转，每个节点均为业务活动（a.b两位数字编码）
> 使用mermaid流程图，体现全流程主要节点
> 业务流程的节点，跟能力定义的API能力、容器架构、API设计数字编码一一对应

```mermaid
flowchart LR
    S([流程开始]) --> A[1.1 业务节点A]
    A --> B[1.2 业务节点B]
    B --> E([流程结束])
```

### 3. 领域模型
> 采用领域驱动设计（DDD），描述核心领域对象（阐述对象类型和关键属性）及关系

|领域对象|对象类型|对象属性|
|---|---|---|
|RootAggregate|聚合根|包括XX、XX、XX属性|
|EntityA|实体|包括XX、XX、XX属性|

```mermaid
erDiagram
    RootAggregate }|--|| EntityA : "关系A"
    RootAggregate ||--o{ EntityB : "关系B"
```

### 4. 能力定义
> 定义每个业务活动对应的API能力，包括对应的两位数字编码（与业务流程保持一致）
> 明确能力的归属系统、功能说明（关键出入参）、SLA协议（TPS/QPS、TP95/99 RT）

|API能力|归属系统|能力说明|SLA协议|
|---|---|---|---|
|1.1 能力名称|所属服务|能力概述<br/>入参：XX<br/>出参：XX|TPS 200<br/>TP95 RT 50ms<br/>TP99 RT 150ms|

## 二、详细设计
### 1. 容器架构
> 介绍分别有那些容器，各容器的职责
- 服务划分
  - 简要描述前后端、服务、数据库等分工。
> 介绍依赖外部哪些容易
- 外部依赖
  - 简要列举外部依赖（如文件存储、MQ、外部服务等）。

> 用Mermaid C4 Container图描述系统各容器及交互关系
> Person跟Container的Rel用业务活动，a.b两位数字编码
> Container之间的Rel用业务任务，a.b.c三位数字编码
> 业务流程、活动与业务流程图、能力定义编号保持一致
> 业务任务编号跟API设计中各个API的关键任务编号保持一致

```mermaid
C4Container
    Person(user, "用户")

    Container_Boundary(c1, "xx系统") {
        Container(app, "应用服务", "技术栈", "描述")
        ContainerDb(db, "数据库", "类型", "描述")
    }

    Rel_D(user, app, "1.1 HTTP调用")
    UpdateRelStyle(user, app, $offsetX="-30", $offsetY="0")
    Rel_D(app, db, "1.1.1 数据存取")
    UpdateRelStyle(app, db, $offsetX="-30", $offsetY="0")
```

### 2. API设计
> 详细设计业务活动对应的API能力，关键任务对应业务任务
> 每个接口用表格描述，字段包括API签名、请求参数、响应结果、关键任务（编号）、状态和异常
> api用做二方服务，service用作内部服务，open用开放服务
> API的编码主要参考该部分设计

a.b 业务活动
|API事项|具体说明|
|----|----|
|API签名|`com.{company}.{business}.{context}.api\|service\|open.{Aggregate}Service.{ability}`|
|请求参数|`{"param":""}`|
|响应结果|`{"result":""}`|
|关键任务|- a.b.1 任务一<br/>- a.b.2 任务二|
|状态和异常|400、500|


### 3. 逻辑模型
#### 关键类图
> 基于领域模型设计的关键领域对象，用类和属性表达
> 采用memarid协议的类图
> 领域模型的编码主要参考该部分设计

```mermaid
classDiagram
    class RootEntity {
        +property1
        +property2
    }
```

#### 状态流转
> 定义聚合根或实体的状态机，描述对象状态流转
> 采用memarid协议的状态图
> 对象状态机的编码主要参考该部分，状态值采用状态码枚举表达

```mermaid
stateDiagram-v2
    [*] --> 状态A
    状态A --> 状态B : 行为
    状态B --> [*]
```

#### 处理时序
> 定义每个API的处理时序，每个API都有独立时序图
> 重点突出关键任务的先后顺序和分层处理机制
> 按用户接口、应用服务、领域服务、基础设施分层，表达一个API接口实现的具体过程
> 应用服务、领域服务、基础设施的编码，主要参考该部分设计

```mermaid
sequenceDiagram
    Actor U as 用户
    participant API as 用户接口
    participant APP as 应用服务
    participant DOMAIN as 领域服务
    participant INFRA as 基础设施
    participant DB as 数据库
    U->>API: a.b 业务活动
    API->>APP: a.b 业务活动
    APP->>DOMAIN: a.b.1 业务任务一
    DOMAIN->>INFRA: 持久化
    INFRA->>DB: 写存储
    APP->>DOMAIN: a.b.2 业务任务二
    DOMAIN->>INFRA: 读模型
    INFRA->>DB: 查存储
    APP-->>API: 返回处理结果
    API-->>U: 返回响应结果
```

### 4. 数据模型
> 定义主要的表实体ER关系和表结构
> 数据实体、存储Mapper的编码，主要参考该部分设计

#### ER关系
```mermaid
erDiagram
    TableA ||--o{ TableB : "1:N"
```
#### 表结构
```sql
-- 表结构示例
CREATE TABLE `table_a` (
    `id` bigint NOT NULL, // 主键id
    PRIMARY KEY (`id`)
);
```
