---
description: 
globs: 
alwaysApply: true
---
---
description:详细设计模板
globs:["'*.md"]
alwaysApply:false
---
# 详细设计模板
> 详设术语定义

|术语|含义|示例|工程对标|数字编码
|----|----|----|----|----|
|业务流程|按照业务发生的顺序和规则表达企业实现目标的各项业务活动|商品发布流程、交易下单流程|工作流程|三位数字编码a.b.c，第一位a代表业务流程
|业务活动|企业实现目标的业务活动，指业务角色办理的业务事项，例如用户发起的一个操作|发布商品、下单|API能力（接口、MQ、Job）|三位数字编码a.b.c，第二位b代表业务活动
|业务任务|完成业务活动的工作程序，是流程的基本组成单元|查询商品详情、创建订单|领域能力|三位数字编码a.b.c，第三位c代表业务任务
|业务步骤|完成任务的具体步骤，是流程的最原子操作|校验商品状态、订单计价|领域服务处理步骤|四位数字编码a.b.c.d，第四位d代表业务步骤
|业务规则|定义或约束业务步骤的细节规则，控制或影响业务行为|商品可用才允许下单|详细的业务判断条件|五位数字编码a.b.c.d.e，第五位e代表业务规则

## 一、业务分析

### 1. 名词定义
> 定义名词，介绍名词含义和案例

|名词|含义|举例|
|-----|-----|------|
| 名词1 | 名词含义，使用场景 | 名词案例 |

### 2. 业务流程
> 表达业务流程流转，每个节点均为业务活动（a.b两位数字编码）
> 使用mermaid流程图，体现全流程主要节点
> 业务流程的节点，跟能力定义的API能力、容器架构、API设计数字编码一一对应

```mermaid
flowchart LR
    S((开始)) --> A[1.1 业务节点A]
    A --> B[1.2 业务节点B]
    B --> E((结束))
```

### 3. 领域模型
> 采用领域驱动设计（DDD），描述核心领域对象（阐述对象类型和关键属性）及关系，建议补充如下内容：
- 明确聚合根、实体、值对象、枚举等类型
- 关键属性建议包含ID、编码、名称、状态、关联对象、条件、公式、要素、扩展属性等
- 建议用表格+mermaid erDiagram/类图表达

|领域对象|对象类型|关键属性|
|---|---|---|
|RootAggregate|聚合根|包括ID、编码、名称、状态、关联对象、条件、扩展属性等|
|EntityA|实体|包括ID、名称、类型、关联聚合根、扩展属性等|
|ValueObjectB|值对象|包括表达式、变量、要素、分支、取值等|
|EnumC|枚举|类型编码、类型名称|

```mermaid
erDiagram
    RootAggregate }|--|| EntityA : "关系A"
    RootAggregate ||--o{ ValueObjectB : "关系B"
    EntityA ||--o{ EnumC : "枚举引用"
```

### 4. 能力定义
> 定义每个业务活动对应的API能力，包括对应的两位数字编码（与业务流程保持一致）
> 明确能力的归属系统、功能说明（关键出入参）、SLA协议（TPS/QPS、TP95/99 RT）

|API能力|归属系统|能力说明|SLA协议|
|---|---|---|---|
|1.1 能力名称|所属服务|能力概述<br/>入参：XX<br/>出参：XX|TPS 200<br/>TP95 RT 50ms<br/>TP99 RT 150ms|

## 二、详细设计
### 1. 容器架构
> 介绍分别有那些容器，各容器的职责
- 服务划分
  - 简要描述前后端、服务、数据库等分工。
> 介绍依赖外部哪些容易
- 外部依赖
  - 简要列举外部依赖（如文件存储、MQ、外部服务等）。

> 用Mermaid C4 Container图描述系统各容器及交互关系
> Person跟Container的Rel用业务活动，a.b两位数字编码
> Container之间的Rel用业务任务，a.b.c三位数字编码
> 业务流程、活动与业务流程图、能力定义编号保持一致
> 业务任务编号跟API设计中各个API的关键任务编号保持一致

```mermaid
C4Container
    Person(user, "用户")

    Container_Boundary(c1, "xx系统") {
        Container(app, "应用服务", "技术栈", "描述")
        ContainerDb(db, "数据库", "类型", "描述")
    }

    Rel_D(user, app, "1.1 HTTP调用")
    UpdateRelStyle(user, app, $offsetX="-30", $offsetY="0")
    Rel_D(app, db, "1.1.1 数据存取")
    UpdateRelStyle(app, db, $offsetX="-30", $offsetY="0")
```

### 2. API设计
> 详细设计业务活动对应的API能力，关键任务对应业务任务
> 建议每个接口用表格描述，字段包括API签名、请求参数、响应结果、关键任务（编号）、状态和异常、SLA等
> 建议补充Dubbo/REST区分、接口幂等性、异常码、关键参数说明

|API事项|具体说明|
|----|----|
|API签名|`com.{company}.{business}.{context}.api|service|open.{Aggregate}Service.{ability}`|
|请求参数|`{"param":""}`|
|响应结果|`{"result":""}`|
|关键任务|- a.b.1 任务一<br/>- a.b.2 任务二|
|状态和异常|400、500、业务异常码|
|SLA|TPS/QPS、TP95/99 RT|

### 3. 逻辑模型
#### 关键类图
> 建议补充领域对象的属性、方法、聚合关系，采用mermaid classDiagram表达

```mermaid
classDiagram
    class RootEntity {
        +property1
        +property2
    }
``` 

#### 状态流转
> 建议补充聚合根/实体的状态机，描述对象状态流转，采用mermaid stateDiagram-v2表达
> 建议标注状态码、关键行为、异常分支

```mermaid
stateDiagram-v2
    [*] --> 状态A
    状态A --> 状态B : 行为
    状态B --> [*]
```

#### 处理时序
> 建议补充API/核心业务流程的处理时序，采用mermaid sequenceDiagram表达，突出关键任务、分层处理机制
> 建议标注外部系统、异步/同步、重试/补偿等机制

```mermaid
sequenceDiagram
    Actor U as 用户
    participant API as 用户接口
    participant APP as 应用服务
    participant DOMAIN as 领域服务
    participant INFRA as 基础设施
    participant DB as 数据库
    
    U->>API: a.b 业务活动
    API->>APP: a.b 业务活动
    APP->>DOMAIN: a.b.1 业务任务一
    DOMAIN->>INFRA: 持久化
    INFRA->>DB: 写存储
    APP->>DOMAIN: a.b.2 业务任务二
    DOMAIN->>INFRA: 读模型
    INFRA->>DB: 查存储
    APP-->>API: 返回处理结果
    API-->>U: 返回响应结果
```

### 4.表结构、字段说明、样例数据
> 建议用mermaid erDiagram表达ER关系，表结构用表格或SQL示例
> 建议标注主键、外键、索引、JSON字段、扩展属性等

#### ER关系

```mermaid
erDiagram
    TableA ||--o{ TableB : "1:N"

    TableA {
        bigint id "id"
        string name "名称"
        int type "类型"    
    }

    TableB {
        bigint id "id"
        string name "名称"
        int type "类型"    
    }
```

#### 表结构

```sql
-- 表结构示例
CREATE TABLE `table_a` (
    `id` bigint NOT NULL, // 主键id
    PRIMARY KEY (`id`)
);
```